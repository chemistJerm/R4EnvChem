# Importing Your Data Into R

```{r, echo = FALSE, message = FALSE, error = FALSE, warning = FALSE}
library(tidyverse)
```


Unlike *Excel*, you can't copy and paste your data into R (or RStudio). Instead you need to *import* your data into R so you can work with it. This chapter will discuss how to get your data from a spreadsheet into R (with some accompanying nuances). This was covered briefly in Chapter 3.4, but here we will be describing the general case.

## .csv files

While there are a myriad of ways data is stored, the data you're likely to encounter in an undergraduate lab will be in the form of a `.csv` or *comma-separated values* file. As the name implies, values are separated by commas (go ahead and open any `.csv` file in any text editor to observe this). Essentially you can think of each line as a row and commas as separating values into columns, which is exactly how R and *Excel* handle `.csv` files. 


Importing a `.csv` file into R simply requires the `read_csv` function from tidyverse. Recall that R, unless specified, uses relative referencing. So in the example below we're importing the `ATR_plastics.csv` from the `data` sub-folder in our project by specifying `"data/ATR_plastics.csv"` and assigning it to the variable `atr_plastics`. Note the inclusion of the file extension `.csv`.

```{r atr-ex-import, echo=TRUE, message=TRUE}

atr_plastics <- read_csv("data/ATR_plastics.csv")
```
A benefit of using `read_csv` is that it prints out the column specifications with each column's name (how you'll reference it in code) and the column value type. Columns can have different data types, but a data type must be consistent within any given column. Having the columns specifications is a good way to ensure R is correctly reading your data. The most common data types are:

  - **int** for integer values (*-1,1, 2, 10, etc.*)
  - **dbl** for doubles (essentially any decimal) or real numbers (*-1.20, 0.0, 1.200, 1e7, etc.*). Also referred to as **numeric** by some functions.
  - **chr** for character vectors or strings (*"A", "chemical", "Howdy ma'am", etc.*)
    - note numbers can be encoded as strings, so while you might read "1" as a number, R treats it as a character, limiting how you can use this value.
  - **lgl** for logical values, either `TRUE` or `FALSE`

We can also quickly inspect either through the *Environment* pane in *RStudio* or quickly with the `head()` function. Note the column specifications under the column name.

```{r}
head(atr_plastics)
```

Note how the first line of the `ATR_plastics.csv` has been interpreted as columns names (or *headers*) by R. This is common practice, and gives you a handle by which you can manipulate your data. If you did not intend for R to interpret the first row as headers you can suppress this with the additional argument `col_names = FALSE`. 

```{r}
head(read_csv("data/atr_plastics.csv", col_names = FALSE))
```


Note in the example below that since the headers are now considered data, the entire column is interpreted as character values. This will happen if a single non-numeric character is introduced in the column, so beware of typos when recording data! If we wanted to skip rows (i.e. to avoid blank rows at the top of our `.csv`), we can use the `skip = n` to skip n rows:
```{r}
head(read_csv("data/atr_plastics.csv", col_names = FALSE, skip = 1))
```
Since there are now no defined column names, R renames them as X1, X2, etc.

### Tibbles vs. data frames

Quick eyes will have noticed the first line from the output above is `# A tibble: 6 x 5`. `Tibbles` are a variation of the `data.frames` introduced in section one, but built specifically for the `tidyverse` family of packages. Whenever possible, we recommend using the tibble format as most tidyverse functions will only work on tibbles. This should be easy enough, as the default output of `read_csv` will always be a tibble.

While `data.frames` and `tibbles` are often interchangeable, it's important to be aware of the difference in case you do run into a rare conflict. In these situations you can readily transform a `tibble` into a `data.frame` by coercion with the `as.data.frame()` function, and vice-versa with the `as_tibble()` function. 

```{r}
df<-as.data.frame(atr_plastics)
class(df)

df<-as.tibble(df)
is_tibble(df)
  
```


## Importing other data types

There are other functions to import different types of tabular data which all function like `read_csv`, such as `read_tsv` for tab-separate value files (`.tsv`) and `read_excel` and `read_xlsx` from the `readxl` package to import *Excel* files. Note most *Excel* files have probably been formatted for legibility (i.e. merged columns), which can lead to errors when importing into R. If you plan on importing *Excel* files, it's probably best to open them in *Excel* to remove any formatting, and then save as `.csv` for smoother importing into R. 

## Saving data

As you progress with your analysis you may want to save intermediate or final datasets. This is readily accomplished using the `write.csv` (for data frames) or `write_csv` (for tibbles) functions. Similar rules apply to how we used `read_csv`, but now the second argument specifies the save location and file name while the first argument is the variable in which the `tibble` or `data.frame` has been stored. Note that R *will not* create a folder this way, so if you're saving to a sub-folder you'll have to make sure it already exists or create it yourself. 

```{r, eval=FALSE}
write_csv(atr_plastics, "data/ATRSaveExample.csv")
```

A benefit of `write_csv` is that it will always save in `UTF-8` encoding and ISO8601 time format. This standardization makes it easier to share your `.csv` files with collaborators/yourself.



## Further reading

See Chapters [10](https://r4ds.had.co.nz/tibbles.html) and [11](https://r4ds.had.co.nz/data-import.html) of *R for Data Science* for some more details on `tibbles` and `read_csv`. 

