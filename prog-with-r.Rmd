# Writing Custom Functions

<!-- Aim of this is to show people how they can include programming features to enhance their coding. Mostly tips and shit to get them started, not an all-encompassing guide --> 

Like most things, learning a little goes a long way. And like most things, it's easy to lose the forest for the trees. That's why we won't focus too much on programming (after all you're chemists, not computer scientists) but we will introduce a few simple yet incredibly powerful elements of custom function writing to help you along with your data science quest. We'll point to several sources for further reading on functions at the end of this chapter. 





## Functions  

Functions allow you to write general purpose code to automate common tasks. They're a great way to decrease repetition and make your code more legible and reproducible. By using functions you'll reduce the number of lines of code, but you'll also only need to check one spot to rectify any potential issues. 
  
To create a function in R you only need `function()`:

```{r, error=TRUE}
funSum <- function(x,y){ #Declare a new function funSum with two arguments: x and y.
  z <- x + y
  paste("The sum of", x, "+", y, "is", z, sep =" ") 
  #The argument sep=" " tells the paste function to separate each value in the brackets 
  #with a single space when printing to the console.
}

funSum(1, 3) #A call to funSum where x = 1 and y = 3
funSum("yes",3) #A call to funSum where x = "yes" and y = 3
```
What we've done is create a function called `funSum` which takes two numeric inputs `x` and `y`, sums the two into `z` and pastes together an output telling us the sum in the form of a string. A couple of things to note: 

  - We need to *explicitly* state which arguments are function will take; in this example they are `x` and `y`. Whatever we pass to `x` or `y` will be carried into the function. 
  - We can't sum non-numeric values, so R returns an error in the second instance
  - Functions create their own environment, therefore *any variable created inside a function only exists inside that function*.
    - In the above example, `x`, `y`, and `z` only exist inside the function.
  - R automatically returns whichever variable is on the last line of the body of the function as its output; but you can explicitly ask for an output using `return()`

Let's take a look at a more practical function, something that you might actually use. In mass spectrometry, a common gauge of accuracy is the *mass error*, a measure of the difference between the observed and theoretical masses, and is reported in parts-per-million (ppm). The formula for calculating mass error is:

$$ Mass~error~(ppm) = \frac{|mass_{theoretical} - mass_{experimental}|}{mass_{theorical}} \times 10^6 $$

The formula is simple enough, but you may need to calculate any number of mass errors, so it behooves us to compose a quick formula to simplify our workload:


```{r}
ppmMS <- function(theoMZ, expMZ){ 
  ppm <- abs(theoMZ - expMZ)/theoMZ * 1e6 
  #Same calculation as in the formula above. 
  #The 'abs()' function returns the absolute of a numeric value.
  return(ppm)
}

ppmMS(theoMZ = 1479.94, expMZ = 1480.01)
#Theoretical mass = 1479.94 m/z
#Experimental mass = 1480.01 m/z
```

Pretty useful if you're manually checking something in your data, but we can also use our functions into the pipe to help with data transformation:


```{r}

#Example data
masses <- data.frame("theo" = c(1479.94, 1479.94, 1479.94), 
                     "exp" = c(1478.94, 1479.94, 1480.01))

masses %>% 
  mutate(massError = ppmMS(theo, exp)) 

```

This last part is critical as *functions make your code more legible*. We can clearly read that the code above is calculating the mass error between the theoretical and experimentally observed masses. This might not be as apparent if we put in a complex mathematical formula in the middle of our pipe. 


## Conditional statments 

These are used to specify a path in a function depending on whether a statement evaluates to `TRUE` or `FALSE`. These are explored in greater detail via the links in the [Further Reading] section, but here's a quick example of a function that uses the conditional `if` statement to print out which number is largest: 

```{r}

isGreater <- function(x, y){ 
  if(x > y){ 
    return(paste(x, "is greater than", y, sep = " ")) 
    #If x is greater than y, stop the function and return the pasted string.
  }else if(x < y){                                  
    #If x is not greater than y, the previous line is not run and a new condition is tested instead. 
    return(paste(x, "is less than", y, sep = " ")) 
    #If x is less than y, stop the function and return the pasted string.
  }
  
  return(paste(x, "is equal to", y, sep = " ")) 
  #If the function makes it to this line, then return this pasted string as the final output.
}

isGreater (2, 1) #Call to isGreater, where x = 2 and y = 1
isGreater (1, 2)
isGreater (1, 1)

```

Our simple function compares two numbers, `x` and `y` and if `x > y` evaluate to `TRUE` it returns the pasted string `x is greater than y`. If `x < y` evaluates to `FALSE`, as in `y > x`, our function returns the pasted string `x is less than y`, and finally if neither `x > y` and `x < y` evaluate to TRUE, they must be equal! Therefore the final output is `x is equal to y`. This is an example of an `else if` statement. If you're simply evaluating two conditions (`TRUE` or `FALSE`) you only need the `if()` conditional, see [Further Reading] for more details. 

### Piping conditional statements

You can already see the potential for simply conditional statements in the pipe. However, to keep piping operations legible, `dplyr` offers the `if_else` function, which works similarly to the `else if` statements showcased above. Let's see how it works using a real world example.

In mass spectrometry undetected compounds are recorded by the instrument as having an intensity of 0, but it's a common practice to replace 0 with $\frac{limit~of~detection}{2}$ for subsequent analysis. However we don't want to replace every value with $\frac{LOD}{2}$, only 0s. Let's use the `if_else` function to create new values from the recorded intensities.

```{r}

lod <- 4000 #Previously calculated LOD (limit of detection)
results <- data.frame("mz" = c(308.97, 380.81, 410.11, 445.34 ), 
                      "intensities" = c(0, 1000, 5000, 10000)) 

removeLow_IC <- function(mzTable, limDetect){ 
  
  adj_intensities<-mzTable %>% 
    mutate(reportedIntensities = if_else(intensities < limDetect, limDetect/2, intensities))
    #Create a new column 'reportedIntensities' where, for every value in the 
    #intensities column, if it is less than than the value of limDetect, then assign 
    #a value of limDetect/2 to that row of the new column. If not, then copy the 
    #original intensity value to that row of the new column.
  
  return(adj_intensities)
}

final_results<-removeLow_IC(results, lod) 
#Call the function 'removeLowIC', with mzTable = results and limDetect = lod
final_results

```

First we're creating a new column called `reportedIntensities` using `mutate()`, then using `if_else()` to conditionally fill that column one row at a time. The `if_else` function works just like the `else if` statements from before, but all in one line so we can use it within a pipe chain. The first parameter is the condition being tested (`intensities < limDetect`), the second parameter is the value to return if the condition is `TRUE`, and the third parameter is the value to return if the condition is `FALSE`.
<!-- I'll leave this here in case you want to bring it back, but I think it makes more sense to teach if_else() here. case_when() is only really useful when you have a lot of cases to test, and skipping it here also lets us push having to explain the tilde operator until we get to modelling, where they'll use it far more often anyway. -->

<!--The inputs we've passed to `case_when()` are two-sided formulas. Essentially if the conditions on the left-hand side of the tilda (`~`) evaluate to `TRUE`, `case_when` will execute the right-hand side. Thee first two-sided formula is `intensities < lod ~ lod/2` and checks if the intensities value is less than the previously calculated limit of detection. If `intensitis < lod` evaluates to `TRUE` we insert half of the LOD value for that row. If `intentisites < lod` evaluates to `FALSE`, we move onto the next two-side formula and reevaluate again. The second two-sided formula `TRUE ~ intensities` basically means for everything that's remaining (greater than LOD in our instance) just use the value from the `intensities` column.

Some ideas to consider when working with `case-when()`:

  - There's no limits to the conditions you can pass to `case_when()`.
  - *However* `case_when()` evaluates in order, so remember to put the more specific conditions before the more general ones. 
  - Remember that the point of `case_when()` and piping is legibility. If you're passing multiple conditions, consider writing a function using `else if` statements to keep the pipe legible.  
-->

## Troubleshooting error messages

We briefly mentioned error messages in Chapter 3.1, but once you start writing your own code you will inevitably come across many more. Here we'll go through a few of the more common errors you'll encounter and how to fix your code to resolve the issues.


### Script diagnostics

When writing code in the Script window, RStudio will highlight any syntax errors in your code with a red squiggly line and an 'x' in the side bar, as shown below. You can hover over the 'x' to see what is causing the error. 

![Figure 3.8: RStudio highlights syntax errors in the Scripts window.](images/Rstudio_diagnostics.png)

In the above message, R is telling you that it is not sure what to do with `b`. As mentioned previously, variable assignment is done in the format `name <- assignment`. However, in the above example, the variable assignment statement is written as `name name <- assignment`. Since variable names cannot contain spaces, R reads `a b` as two separate input variable names, not as a single string. If you wanted to assign a value of 0 to both `a` and `b`, you would need to write the statement once per variable, as shown below.

```{r}
a <- 0
b <- 0
```

Let's look at another example. Some functions require you to write code with nested parentheses. A good example would be the `aes()` argument that is called inside of `ggplot()`, as shown below.

```{r message = FALSE, echo = FALSE}
library(readr)
library(ggplot2)

#import ozone data set
airPol <- read_csv("data/2018-01-01_60430_Toronto_ON.csv")
```

```{r eval = FALSE}
#plot ozone concentration vs. time
ggplot(data = airPol, 
       aes(x = date.time,
           y = concentration,
           colour = pollutant)) +
  geom_point()
```

(For more detail about importing and using `ggplot2`, please re-visit Chapter 2, section 2.3.4, or see Chapter 11.)

If you were to forget one of the parentheses in the previous line of code, RStudio would highlight it similar to below:

![Figure 3.9: RStudio highlights unmatched parentheses in the script window.](images/Rstudio_unmatched.png)

Here R is telling you that you have an unmatched opening bracket. To resolve the error, simply add a closing bracket to match. 

The `expected ',' after expression` is a common error that you will see accompanying unmatched opening brackets. Sometimes you might get this error in the console after running code that is missing a bracket somewhere. It is good practice to check your parentheses a few times before running your code to make sure that all the commands are closed, and that R doesn't keep waiting for you to continue inputting code after you've click *Run*. If you notice that the `>` in your R console has turned into a `+`, this is likely because you've just run a command that is missing a closing bracket, and thus, R is not aware that your code is finished. Simply input a closing bracket into the console, and the `>` should return.

### Console error codes

While the script window is very useful for pointing out syntax errors in your code, there are many other errors that can arise in RStudio which the script window is not able to capture. These are generally errors that arise from trying to execute your code, rather than from mistakes in your syntax.

The following is a prime example of such an error.

```{r error = TRUE}
q <- 8 + "hi"
```

Here we are trying to add a numeric value (8) to a character string ("hi"), then set the sum of the two to variable `q`. R has given us an error in return, because there is no logical way for R to add a numeric value to non-numeric text.

The error indicates that we have passed a `non-numeric argument to binary operator`, meaning we have used a non-numeric data type for an expression which is exclusively reserved for numeric data. If you try to add, divide or multiply two character strings using arithmetic operations in the console, you will get the same error. 

```{r error = TRUE}
"hey" * "hi"
```

It is important to be aware of these error codes as many functions require specific data types as their inputs. You can always look at the required data type by looking at the documentation for the function (generally, this can be viewed by typing `?function` into the console, where `function` is the name of the function). If the function requires numeric data, inputting character strings or logical values will throw the errors shown above. If the function requires logical values, inputting numeric data or character strings will throw the errors shown above. 

In order to avoid these errors, make sure that you are using the right type of data in your functions. You can always check your data type using `class()`. Some examples are shown below.

```{r}
class("hi")

class(10)

class(1L)

class(TRUE)
```


## Further reading

These chapter has been intentionally broad, as functional programming in R is somewhat outside the intended scope of this book. We've omitted several aspects of programming in R, such as `for` loops and other iterative techniques. To get a better sense of what's possible with R programming and to learn more, please refer to the following links:

  - [if_else()](https://dplyr.tidyverse.org/reference/if_else.html): the documentation for the `if_else` function.
  - [case_when()](https://dplyr.tidyverse.org/reference/case_when.html): the documentation for a more advanced conditional function which can evaluate multiple statements simultaneously. 
  - [Chapter 19: Functions](https://r4ds.had.co.nz/functions.html), [Chapter 20: Vectors](https://r4ds.had.co.nz/vectors.html), and [Chapter 21: Iteration](https://r4ds.had.co.nz/iteration.html) of [*R for Data Science*](https://r4ds.had.co.nz/index.html) by H. Wickham and G. Grolemund.  
  - [Hands-on Programming in R](https://rstudio-education.github.io/hopr/) by G. Grolemund for a more in-depth (but still approachable) take on programming in R. 